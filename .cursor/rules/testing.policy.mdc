---
globs: *
alwaysApply: true
---
# Pol√≠tica de Testes

## Objetivo
Garantir cobertura adequada de testes para todas as altera√ß√µes de c√≥digo, mantendo qualidade e confiabilidade do sistema.

## üöÄ Quick Start

### **Comandos Essenciais:**
```bash
# Executar todos os testes
python -m pytest tests/unit/ -v

# Executar com cobertura
python -m pytest tests/unit/ --cov=src --cov-report=term-missing

# Executar teste espec√≠fico
python -m pytest tests/unit/test_models.py::test_transaction_creation -v

# Executar com debug
python -m pytest tests/unit/ -v -s --tb=short
```

### **Estrutura de Teste (AAA Pattern):**
```python
def test_function_should_return_expected_result():
    # Arrange - Preparar dados
    input_data = {"key": "value"}
    expected_result = "expected"
    
    # Act - Executar fun√ß√£o
    result = function_under_test(input_data)
    
    # Assert - Verificar resultado
    assert result == expected_result
```

### **Cobertura M√≠nima:**
- **C√≥digo novo**: 80%
- **C√≥digo cr√≠tico**: 90%
- **Fun√ß√µes de utilidade**: 100%

## Regras Principais

## Sempre na execu√ß√£o dos teste pedir para executar o comando( mostrar o comando ) e informar a saida. 

### ‚úÖ **Sempre criar/atualizar testes quando:**
- Criar novas fun√ß√µes ou classes
- Modificar l√≥gica de neg√≥cio existente
- Corrigir bugs (teste de regress√£o)
- Adicionar novas funcionalidades
- Refatorar c√≥digo cr√≠tico

### ‚úÖ **Tipos de teste obrigat√≥rios:**
- **Testes unit√°rios**: Para fun√ß√µes e m√©todos individuais
- **Testes de integra√ß√£o**: Para fluxos completos
- **Testes de regress√£o**: Para bugs corrigidos

## Estrutura de Testes

### **Organiza√ß√£o de arquivos:**
```
tests/
‚îú‚îÄ‚îÄ unit/
‚îÇ   ‚îú‚îÄ‚îÄ test_models.py
‚îÇ   ‚îú‚îÄ‚îÄ test_services.py
‚îÇ   ‚îî‚îÄ‚îÄ test_utils.py
‚îú‚îÄ‚îÄ integration/
‚îÇ   ‚îú‚îÄ‚îÄ test_pdf_processing.py
‚îÇ   ‚îî‚îÄ‚îÄ test_excel_processing.py
‚îî‚îÄ‚îÄ fixtures/
    ‚îú‚îÄ‚îÄ sample_data.json
    ‚îî‚îÄ‚îÄ mock_responses.py
```

### **Conven√ß√µes de nomenclatura:**
- Arquivos: `test_<module_name>.py`
- Classes: `Test<ClassName>`
- M√©todos: `test_<functionality>_<expected_result>`

## Padr√µes de Qualidade

### **Cobertura m√≠nima:**
- **C√≥digo novo**: 80% de cobertura
- **C√≥digo cr√≠tico**: 90% de cobertura
- **Fun√ß√µes de utilidade**: 100% de cobertura

### **Estrutura de teste (AAA Pattern):**
```python
def test_function_should_return_expected_result():
    # Arrange - Preparar dados
    input_data = {"key": "value"}
    expected_result = "expected"
    
    # Act - Executar fun√ß√£o
    result = function_under_test(input_data)
    
    # Assert - Verificar resultado
    assert result == expected_result
```

## Testes Espec√≠ficos do Projeto

### **Para processamento de PDFs:**
```python
def test_pdf_reader_valid_file():
    """Testa leitura de PDF v√°lido."""
    reader = PDFStatementReader()
    statement = reader.read("data/samples/20250507_Extrato_Integrado.pdf")
    
    assert statement.bank_name == "Banco BPI"
    assert len(statement.transactions) > 0
    assert statement.currency == "EUR"

def test_pdf_reader_invalid_file():
    """Testa leitura de PDF inv√°lido."""
    reader = PDFStatementReader()
    
    with pytest.raises(ParsingError):
        reader.read("invalid_file.pdf")
```

### **Para processamento de Excel:**
```python
def test_excel_reader_different_formats():
    """Testa diferentes formatos de planilha."""
    reader = ExcelStatementReader()
    
    # Teste com formato BPI
    statement = reader.read("data/samples/extmovs_bpi2108102947.xlsx")
    assert statement.bank_name == "Banco BPI"
    
    # Teste com formato gen√©rico
    statement = reader.read("data/samples/generic_format.xlsx")
    assert len(statement.transactions) > 0

def test_excel_reader_data_validation():
    """Testa valida√ß√£o de dados."""
    reader = ExcelStatementReader()
    
    # Teste com dados malformados
    with pytest.raises(ParsingError):
        reader.read("data/samples/malformed_data.xlsx")
```

### **Para categoriza√ß√£o:**
```python
def test_transaction_categorization():
    """Testa categoriza√ß√£o de transa√ß√µes."""
    categorizer = KeywordCategorizer()
    
    # Teste com transa√ß√£o de supermercado
    transaction = Transaction(
        date=datetime.now(),
        description="SUPERMERCADO CONTINENTE",
        amount=Decimal("50.00"),
        type=TransactionType.DEBIT
    )
    
    categorized = categorizer.categorize([transaction])
    assert categorized[0].category == TransactionCategory.ALIMENTACAO

def test_categorization_edge_cases():
    """Testa casos extremos de categoriza√ß√£o."""
    categorizer = KeywordCategorizer()
    
    # Teste com descri√ß√£o vazia
    transaction = Transaction(
        date=datetime.now(),
        description="",
        amount=Decimal("100.00"),
        type=TransactionType.CREDIT
    )
    
    categorized = categorizer.categorize([transaction])
    assert categorized[0].category == TransactionCategory.NAO_CATEGORIZADO
```

## Execu√ß√£o de Testes

### **Comandos b√°sicos:**
```bash
# Executar todos os testes
python -m pytest

# Executar com cobertura
python -m pytest --cov=src --cov-report=html

# Executar testes espec√≠ficos
python -m pytest tests/unit/test_models.py
```

### **Integra√ß√£o cont√≠nua:**
- Testes devem passar antes de commit
- Cobertura n√£o deve diminuir
- Testes devem ser r√°pidos (<30s total)

## Mocks e Fixtures

### **Quando usar mocks:**
- APIs externas
- Opera√ß√µes de arquivo
- Depend√™ncias custosas
- Comportamentos n√£o-determin√≠sticos

### **Fixtures recomendadas:**
```python
@pytest.fixture
def sample_pdf_data():
    return load_test_pdf("sample_extract.pdf")

@pytest.fixture
def mock_bank_api():
    with patch('src.services.bank_api') as mock:
        yield mock
```

## Mensagens de Commit

### **Formato para commits com testes:**
```
<tipo>(<escopo>): <descri√ß√£o>

- Adiciona testes para <funcionalidade>
- Cobertura: <percentual>%
- Casos testados: <lista_resumida>
```

### **Exemplos:**
```
feat(pdf): adiciona extra√ß√£o de saldo inicial

- Adiciona testes para extra√ß√£o de saldo
- Cobertura: 85%
- Casos testados: PDF v√°lido, inv√°lido, formato europeu

test(excel): melhora cobertura de processamento

- Adiciona testes para casos extremos
- Cobertura: 92%
- Casos testados: planilhas vazias, dados malformados
```

## Valida√ß√£o Antes do Commit

Confirme que:
1. ‚úÖ Todos os testes passam
2. ‚úÖ Cobertura n√£o diminuiu
3. ‚úÖ Novos testes foram adicionados para c√≥digo novo
4. ‚úÖ Testes de regress√£o para bugs corrigidos
5. ‚úÖ Documenta√ß√£o de testes atualizada
6. ‚úÖ Fixtures e mocks apropriados

## üêõ Debugging de Testes

### **Comandos de Debug:**
```bash
# Executar com output detalhado
python -m pytest tests/unit/test_models.py -v -s

# Executar apenas um teste espec√≠fico
python -m pytest tests/unit/test_models.py::test_transaction_creation -v -s

# Executar com traceback completo
python -m pytest tests/unit/test_models.py --tb=long

# Executar com pdb (debugger)
python -m pytest tests/unit/test_models.py --pdb

# Executar com logging
python -m pytest tests/unit/test_models.py -v -s --log-cli-level=DEBUG
```

### **T√©cnicas de Debug:**
```python
def test_complex_function():
    """Exemplo de teste com debugging."""
    # Arrange
    input_data = {"key": "value"}
    
    # Debug: Imprimir dados de entrada
    print(f"Input data: {input_data}")
    
    # Act
    result = function_under_test(input_data)
    
    # Debug: Imprimir resultado
    print(f"Result: {result}")
    
    # Assert
    assert result is not None
    assert result["status"] == "success"
```

### **Problemas Comuns e Solu√ß√µes:**

#### **1. Teste Falhando Sem Motivo Claro:**
```bash
# Executar com traceback longo
python -m pytest tests/unit/test_models.py --tb=long -v

# Verificar se h√° imports faltando
python -c "import sys; print(sys.path)"
```

#### **2. Mock N√£o Funcionando:**
```python
# Verificar se o mock est√° sendo aplicado
@patch('src.services.bank_api.BankAPI.get_balance')
def test_balance_retrieval(mock_get_balance):
    mock_get_balance.return_value = Decimal("1000.00")
    
    # Debug: Verificar se mock foi chamado
    print(f"Mock called: {mock_get_balance.called}")
    print(f"Mock call count: {mock_get_balance.call_count}")
```

#### **3. Dados de Teste Incorretos:**
```python
def test_with_real_data():
    """Teste com dados reais para debug."""
    # Carregar dados reais
    with open("data/samples/real_transaction.json") as f:
        real_data = json.load(f)
    
    # Debug: Imprimir estrutura dos dados
    print(f"Real data structure: {real_data.keys()}")
    
    # Executar teste
    result = process_transaction(real_data)
    assert result is not None
```

### **Ferramentas de Debug:**
- **pytest-sugar**: Interface mais amig√°vel
- **pytest-html**: Relat√≥rios HTML
- **pytest-clarity**: Assertions mais claras
- **pytest-mock**: Mocking simplificado

## Ferramentas Recomendadas

- **pytest**: Framework principal
- **pytest-cov**: Cobertura de c√≥digo
- **pytest-mock**: Mocking simplificado
- **pytest-xdist**: Execu√ß√£o paralela
- **factory-boy**: Gera√ß√£o de dados de teste
- **pytest-sugar**: Interface amig√°vel
- **pytest-html**: Relat√≥rios HTML
- **pytest-clarity**: Assertions claras