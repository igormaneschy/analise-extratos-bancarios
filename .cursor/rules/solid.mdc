---
description: "Princ√≠pios SOLID para design orientado a objetos"
globs: ["src/**/*", "app/**/*", "domain/**/*"]
alwaysApply: true
---

## Objetivo
Promover design modular, extens√≠vel e de f√°cil manuten√ß√£o.

## üöÄ Quick Reference

### **Princ√≠pios SOLID:**
- **S** - Single Responsibility: Uma classe, uma responsabilidade
- **O** - Open/Closed: Aberto para extens√£o, fechado para modifica√ß√£o
- **L** - Liskov Substitution: Subtipos substituem tipos base
- **I** - Interface Segregation: Interfaces espec√≠ficas e pequenas
- **D** - Dependency Inversion: Dependa de abstra√ß√µes, n√£o implementa√ß√µes

### **Quando Aplicar:**
- ‚úÖ **Sempre**: Em novos desenvolvimentos
- ‚úÖ **Refatora√ß√£o**: Quando c√≥digo est√° dif√≠cil de manter
- ‚úÖ **Extensibilidade**: Quando precisar adicionar funcionalidades
- ‚ö†Ô∏è **Cuidado**: Em sistemas legados (aplicar gradualmente)

---

## 1. Single Responsibility Principle (SRP)
Cada classe/m√≥dulo deve ter uma √∫nica responsabilidade.

‚úÖ Correto:
```python
class BankStatementReader:
    def read(self, file_path: Path) -> BankStatement: ...

class TransactionCategorizer:
    def categorize(self, transactions: List[Transaction]) -> List[Transaction]: ...

class StatementAnalyzer:
    def analyze(self, statement: BankStatement) -> AnalysisResult: ...
```

‚ùå Errado:
```python
class BankStatementProcessor:
    def read(self, file_path: Path) -> BankStatement: ...
    def categorize(self, transactions: List[Transaction]) -> List[Transaction]: ...
    def analyze(self, statement: BankStatement) -> AnalysisResult: ...
    def generate_report(self, analysis: AnalysisResult) -> str: ...
    def send_email(self, report: str) -> None: ...
```

### **Quando Aplicar SRP:**
- ‚úÖ Classe com mais de 200 linhas
- ‚úÖ M√∫ltiplas raz√µes para mudan√ßa
- ‚úÖ Dificuldade para testar
- ‚úÖ Responsabilidades n√£o relacionadas

---

## 2. Open/Closed Principle (OCP)
Entidades devem estar abertas para extens√£o, mas fechadas para modifica√ß√£o.

‚úÖ Correto:
```python
class TransactionCategorizer:
    def categorize(self, transaction: Transaction) -> TransactionCategory: ...

class KeywordCategorizer(TransactionCategorizer):
    def categorize(self, transaction: Transaction) -> TransactionCategory:
        # L√≥gica baseada em palavras-chave
        pass

class MLBasedCategorizer(TransactionCategorizer):
    def categorize(self, transaction: Transaction) -> TransactionCategory:
        # L√≥gica baseada em machine learning
        pass
```

‚ùå Errado:
```python
def categorize_transaction(transaction: Transaction, method: str):
    if method == "keyword":
        # L√≥gica de palavras-chave
        pass
    elif method == "ml":
        # L√≥gica de ML
        pass
    elif method == "rule_based":
        # L√≥gica baseada em regras
        pass
```

### **Quando Aplicar OCP:**
- ‚úÖ M√∫ltiplas implementa√ß√µes de uma funcionalidade
- ‚úÖ Necessidade de adicionar novos tipos sem modificar c√≥digo existente
- ‚úÖ Diferentes algoritmos para a mesma opera√ß√£o

---

## 3. Liskov Substitution Principle (LSP)
Subtipos devem poder substituir seus tipos base sem alterar o funcionamento.

‚úÖ Correto:
```python
class Bird:
    def fly(self): ...

class Sparrow(Bird):
    def fly(self): print("Flying low")
```

‚ùå Errado:
```python
class Ostrich(Bird):
    def fly(self): raise Exception("I can't fly!")
```

---

## 4. Interface Segregation Principle (ISP)
Prefira v√°rias interfaces espec√≠ficas a uma interface gen√©rica e pesada.

‚úÖ Correto:
```python
class Workable:
    def work(self): ...

class Feedable:
    def eat(self): ...
```

‚ùå Errado:
```python
class Worker:
    def work(self): ...
    def eat(self): ...
```

---

## 5. Dependency Inversion Principle (DIP)
Dependa de abstra√ß√µes, n√£o de implementa√ß√µes.

‚úÖ Correto:
```python
class Repository(ABC):
    def save(self, entity): ...

class SqlRepository(Repository):
    def save(self, entity): ...
```

‚ùå Errado:
```python
class Service:
    def __init__(self):
        self.repo = SqlRepository()  # Forte acoplamento
```

---

## ‚öñÔ∏è Trade-offs e Exce√ß√µes

### **Quando Quebrar os Princ√≠pios SOLID:**

#### **1. SRP - Exce√ß√µes Aceit√°veis:**
- **DTOs/Value Objects**: Podem ter m√∫ltiplas responsabilidades relacionadas
- **Factories**: Podem criar e configurar objetos
- **Facades**: Podem orquestrar m√∫ltiplas opera√ß√µes

```python
# ‚úÖ Aceit√°vel - DTO com m√∫ltiplas responsabilidades relacionadas
@dataclass
class BankStatement:
    bank_name: str
    account_number: str
    transactions: List[Transaction]
    
    def get_total_credits(self) -> Decimal: ...
    def get_total_debits(self) -> Decimal: ...
    def get_balance_variation(self) -> Decimal: ...
```

#### **2. OCP - Quando Modificar √© Melhor:**
- **Bugs cr√≠ticos**: Corre√ß√µes urgentes podem exigir modifica√ß√£o
- **Performance**: Otimiza√ß√µes podem requerer mudan√ßas internas
- **Legacy code**: Refatora√ß√£o gradual √© prefer√≠vel

#### **3. LSP - Exce√ß√µes Necess√°rias:**
- **Abstract base classes**: Podem ter m√©todos abstratos
- **Interface segregation**: Quebrar em interfaces menores

#### **4. ISP - Interfaces Grandes Aceit√°veis:**
- **Core domain interfaces**: Interfaces fundamentais do dom√≠nio
- **Framework interfaces**: Quando seguindo padr√µes estabelecidos

#### **5. DIP - Depend√™ncias Concretas Aceit√°veis:**
- **Value objects**: Depend√™ncias de tipos primitivos
- **Framework classes**: Depend√™ncias de bibliotecas est√°veis
- **Configuration**: Depend√™ncias de configura√ß√£o

### **M√©tricas de Conformidade:**
- **SRP**: Classes com < 200 linhas, < 5 m√©todos p√∫blicos
- **OCP**: < 10% de modifica√ß√µes em classes existentes por release
- **LSP**: 100% dos testes passam com implementa√ß√µes substitutas
- **ISP**: Interfaces com < 5 m√©todos p√∫blicos
- **DIP**: > 80% das depend√™ncias s√£o abstra√ß√µes

### **Ferramentas de Valida√ß√£o:**
```bash
# Verificar complexidade ciclom√°tica
radon cc src/ --min B

# Verificar acoplamento
vulture src/ --min-confidence 60

# Verificar coes√£o
pylint src/ --disable=all --enable=similarities
```
